/*
 * Copyright (C) 2002-2015 Sebastiano Vigna
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License. 
 */
package com.github.tommyettinger.ds;

import java.util.*;

import static com.github.tommyettinger.ds.CrossHash.*;

/**
 * A generic linked hash set with with a fast implementation, originally from fastutil as ObjectLinkedOpenHashSet but
 * modified to support indexed access of items, reordering, and optional hash strategies for array keys (which fastutil
 * does differently).
 * <p>
 * Instances of this class use a hash table to represent a set. The table is
 * filled up to a specified <em>load factor</em>, and then doubled in size to
 * accommodate new entries. If the table is emptied below <em>one fourth</em> of
 * the load factor, it is halved in size. However, halving is not performed when
 * deleting entries from an iterator, as it would interfere with the iteration
 * process.
 * </p>
 * <p>
 * Note that {@link #clear()} does not modify the hash table size. Rather, a
 * family of {@linkplain #trim() trimming methods} lets you control the size of
 * the table; this is particularly useful if you reuse instances of this class.
 * </p>
 * <p>
 * Iterators generated by this set will enumerate elements in the same order in
 * which they have been added to the set (addition of elements already present
 * in the set does not change the iteration order). Note that this order has
 * nothing in common with the natural order of the keys. The order is kept by
 * means of an array list, represented <i>via</i> an IntVLA parallel to the
 * table that can be modified with methods like {@link #shuffle(Random)}.
 * </p>
 * <p>
 * This class implements the interface of a sorted set, so to allow easy access
 * of the iteration order: for instance, you can get the first element in
 * iteration order with {@code first()} without having to create an iterator;
 * however, this class partially violates the {@link SortedSet}
 * contract because all subset methods throw an exception and
 * {@link #comparator()} returns always <code>null</code>.
 * <p>
 * <p>
 * Additional methods, such as <code>addAndMoveToFirst()</code>, make it easy to
 * use instances of this class as a cache (e.g., with LRU policy).
 * </p>
 * <p>
 * This class allows approximately constant-time lookup of keys or values by their index in the ordering, which can
 * allow some novel usage of the data structure. IndexedSet can be used like a list of unique elements, keeping order
 * like a list does but also allowing rapid checks for whether an item exists in the IndexedSet, and {@link IndexedMap}
 * can be used like that but with values associated as well (where IndexedSet uses contains(), IndexedMap uses
 * containsKey()). You can also set the item at a position with {@link #addAt(Object, int)}, or alter an item while
 * keeping index the same with {@link #alter(Object, Object)}. Reordering works here too, both with completely random
 * orders from {@link #shuffle(Random)} or with a previously-generated ordering from {@link #reorder(int...)}.
 * </p>
 * <p>
 * You can pass an {@link IHasher} instance such as {@link CrossHash#generalHasher} as an extra parameter to
 * most of this class' constructors, which allows the IndexedSet to use arrays (usually primitive arrays) as items. If
 * you expect only one type of array, you can use an instance like {@link CrossHash#intHasher} to hash int arrays, or
 * the aforementioned generalHasher to hash most kinds of arrays (it can't handle most multi-dimensional arrays well).
 * If you aren't using array items, you don't need to give an IHasher to the constructor and can ignore this feature.
 * </p>
 * <br>
 * Thank you, Sebastiano Vigna, for making FastUtil available to the public with such high quality.
 * <br>
 * See https://github.com/vigna/fastutil for the original library.
 *
 * @author Sebastiano Vigna (responsible for all the hard parts)
 * @author Tommy Ettinger (mostly responsible for squashing several layers of parent classes into one monster class)
 */
public class IndexedSetCustom<K> extends IndexedSet<K> implements SortedSet<K>, java.io.Serializable, Cloneable {
    private static final long serialVersionUID = 1L;

    protected final IHasher hasher;

    /**
     * Creates a new hash map.
     * <p>
     * <p>The actual table size will be the least power of two greater than <code>expected</code>/<code>f</code>.
     *
     * @param expected the expected number of elements in the hash set.
     * @param f        the load factor.
     */

    @SuppressWarnings("unchecked")
    public IndexedSetCustom(final int expected, final float f) {
        super(expected, f);
        hasher = CrossHash.mildHasher;
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load
     * factor.
     *
     * @param expected the expected number of elements in the hash set.
     */
    public IndexedSetCustom(final int expected) {
        this(expected, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash set with initial expected
     * {@link #DEFAULT_INITIAL_SIZE} elements and
     * {@link #DEFAULT_LOAD_FACTOR} as load factor.
     */
    public IndexedSetCustom() {
        this(DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash set copying a given collection.
     *
     * @param c a {@link Collection} to be copied into the new hash set.
     * @param f the load factor.
     */
    public IndexedSetCustom(final Collection<? extends K> c,
                            final float f) {
        this(c.size(), f, (c instanceof IndexedSetCustom) ? ((IndexedSetCustom) c).hasher : CrossHash.mildHasher);
        addAll(c);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load
     * factor copying a given collection.
     *
     * @param c a {@link Collection} to be copied into the new hash set.
     */
    public IndexedSetCustom(final Collection<? extends K> c) {
        this(1, (c instanceof IndexedSetCustom) ? ((IndexedSetCustom) c).f : DEFAULT_LOAD_FACTOR, (c instanceof IndexedSetCustom) ? ((IndexedSetCustom) c).hasher : mildHasher);
        if(c instanceof IndexedSetCustom){
            IndexedSetCustom<? extends K> cc = ((IndexedSetCustom<? extends K>) c);
            this.n = cc.n;
            this.mask = cc.mask;
            this.maxFill = cc.maxFill;
            this.containsNull = cc.containsNull;
            this.size = cc.size;
            this.key = Arrays.copyOf(cc.key, cc.key.length);
            this.order = new IntVLA(cc.order);
        }
        else
        {
            int expected = c.size();
            n = arraySize(expected, f);
            mask = n - 1;
            maxFill = maxFill(n, f);
            key = (K[]) new Object[n + 1];
            order = new IntVLA(expected);
            addAll(c);
        }

    }

    /**
     * Creates a new hash set using elements provided by a type-specific
     * iterator.
     *
     * @param i a type-specific iterator whose elements will fill the set.
     * @param f the load factor.
     */
    public IndexedSetCustom(final Iterator<? extends K> i, final float f) {
        this(DEFAULT_INITIAL_SIZE, f);
        while (i.hasNext())
            add(i.next());
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load
     * factor using elements provided by a type-specific iterator.
     *
     * @param i a type-specific iterator whose elements will fill the set.
     */
    public IndexedSetCustom(final Iterator<? extends K> i) {
        this(i, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash set and fills it with the elements of a given array.
     *
     * @param a      an array whose elements will be used to fill the set.
     * @param offset the first element to use.
     * @param length the number of elements to use.
     * @param f      the load factor.
     */
    public IndexedSetCustom(final K[] a, final int offset,
                            final int length, final float f) {
        this(length < 0 ? 0 : length, f);
        if (a == null) throw new NullPointerException("Array passed to IndexedSet constructor cannot be null");
        if (offset < 0) throw new ArrayIndexOutOfBoundsException("Offset (" + offset + ") is negative");
        if (length < 0) throw new IllegalArgumentException("Length (" + length + ") is negative");
        if (offset + length > a.length) {
            throw new ArrayIndexOutOfBoundsException(
                    "Last index (" + (offset + length) + ") is greater than array length (" + a.length + ")");
        }
        for (int i = 0; i < length; i++)
            add(a[offset + i]);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load
     * factor and fills it with the elements of a given array.
     *
     * @param a      an array whose elements will be used to fill the set.
     * @param offset the first element to use.
     * @param length the number of elements to use.
     */
    public IndexedSetCustom(final K[] a, final int offset,
                            final int length) {
        this(a, offset, length, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash set copying the elements of an array.
     *
     * @param a an array to be copied into the new hash set.
     * @param f the load factor.
     */
    public IndexedSetCustom(final K[] a, final float f) {
        this(a, 0, a.length, f);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load
     * factor copying the elements of an array.
     *
     * @param a an array to be copied into the new hash set.
     */
    public IndexedSetCustom(final K[] a) {
        this(a, DEFAULT_LOAD_FACTOR);
    }

    /**
     * Creates a new hash map.
     * <p>
     * <p>The actual table size will be the least power of two greater than <code>expected</code>/<code>f</code>.
     *
     * @param expected the expected number of elements in the hash set.
     * @param f        the load factor.
     * @param hasher   used to hash items; typically only needed when K is an array, where CrossHash has implementations
     */
    @SuppressWarnings("unchecked")
    public IndexedSetCustom(final int expected, final float f, IHasher hasher) {
        super(expected, f);
        this.hasher = hasher == null ? CrossHash.mildHasher : hasher;
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load
     * factor.
     *
     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations
     */
    public IndexedSetCustom(IHasher hasher) {
        this(DEFAULT_INITIAL_SIZE, DEFAULT_LOAD_FACTOR, hasher);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load
     * factor.
     *
     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations
     */
    public IndexedSetCustom(final int expected, IHasher hasher) {
        this(expected, DEFAULT_LOAD_FACTOR, hasher);
    }

    /**
     * Creates a new hash set copying a given collection.
     *
     * @param c      a {@link Collection} to be copied into the new hash set.
     * @param f      the load factor.
     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations
     */
    public IndexedSetCustom(final Collection<? extends K> c,
                            final float f, IHasher hasher) {
        this(c.size(), f, hasher);
        addAll(c);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load
     * factor copying a given collection.
     *
     * @param c      a {@link Collection} to be copied into the new hash set.
     * @param hasher used to hash items; typically only needed when K is an array, where CrossHash has implementations
     */
    public IndexedSetCustom(final Collection<? extends K> c, IHasher hasher) {
        this(c, DEFAULT_LOAD_FACTOR, hasher);
    }

    /**
     * Creates a new hash set and fills it with the elements of a given array.
     *
     * @param a      an array whose elements will be used to fill the set.
     * @param offset the first element to use.
     * @param length the number of elements to use.
     * @param f      the load factor.
     */
    public IndexedSetCustom(final K[] a, final int offset,
                            final int length, final float f, IHasher hasher) {
        this(length < 0 ? 0 : length, f, hasher);
        if (a == null) throw new NullPointerException("Array passed to IndexedSet constructor cannot be null");
        if (offset < 0) throw new ArrayIndexOutOfBoundsException("Offset (" + offset + ") is negative");
        if (length < 0) throw new IllegalArgumentException("Length (" + length + ") is negative");
        if (offset + length > a.length) {
            throw new ArrayIndexOutOfBoundsException(
                    "Last index (" + (offset + length) + ") is greater than array length (" + a.length + ")");
        }
        for (int i = 0; i < length; i++)
            add(a[offset + i]);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load
     * factor and fills it with the elements of a given array.
     *
     * @param a      an array whose elements will be used to fill the set.
     * @param offset the first element to use.
     * @param length the number of elements to use.
     */
    public IndexedSetCustom(final K[] a, final int offset,
                            final int length, IHasher hasher) {
        this(a, offset, length, DEFAULT_LOAD_FACTOR, hasher);
    }

    /**
     * Creates a new hash set copying the elements of an array.
     *
     * @param a an array to be copied into the new hash set.
     * @param f the load factor.
     */
    public IndexedSetCustom(final K[] a, final float f, IHasher hasher) {
        this(a, 0, a.length, f, hasher);
    }

    /**
     * Creates a new hash set with {@link #DEFAULT_LOAD_FACTOR} as load
     * factor copying the elements of an array.
     *
     * @param a an array to be copied into the new hash set.
     */
    public IndexedSetCustom(final K[] a, IHasher hasher) {
        this(a, DEFAULT_LOAD_FACTOR, hasher);
    }

    @Override
    protected boolean areEqual(Object left, Object right) {
        return hasher.areEqual(left, right);
    }

    @Override
    protected int hash(Object data) {
        return hasher.hash(data);
    }
}
